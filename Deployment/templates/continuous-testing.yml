parameters:
  - name: AzureSubscription
    type: string    

steps:
  - task: downloadbuildartifacts@0
    displayName: "download functional test artifact"
    inputs:
      buildtype: 'current'
      downloadtype: 'single'
      artifactname: 'functionaltests'
      downloadpath: '$(build.sourcesdirectory)'

  - task: DownloadBuildArtifacts@0
    displayName: "Download ADDSMock Artifact"
    inputs:
      buildType: 'current'
      downloadType: 'single'
      artifactName: 'UKHOADDSMockService'
      downloadPath: '$(Build.SourcesDirectory)'

  - task: PowerShell@2
    displayName: "Extract Artifact ZIP"
    inputs:
      targetType: "inline"
      script: |
        $artifactPath = "$(Build.SourcesDirectory)\UKHOADDSMockService"  # Path where artifact is downloaded
        $zipFile = Get-ChildItem -Path $artifactPath -Filter "*.zip" | Select-Object -First 1
        if ($zipFile) {
            Write-Host "Extracting: $($zipFile.FullName)"
            Expand-Archive -Path $zipFile.FullName -DestinationPath $artifactPath -Force
            Write-Host "Extraction completed!"
        } else {
            Write-Host "No ZIP file found in artifact!"
            exit 1
        }

  # - task: FileTransform@2
  #   displayName: "File Transform: functionaltests"
  #   inputs:
  #      folderPath: '$(Build.SourcesDirectory)/functionaltests/'
  #      xmlTransformationRules:
  #      jsonTargetFiles: '**/appsettings.json'

  - task: UseDotNet@2
    displayName: 'Use .NET 8.0.x sdk'
    inputs:
      packageType: sdk
      version: 8.0.x

  - task: FileTransform@2
    displayName: "File Transform: Mock Service Settings"
    inputs:
      folderPath: '$(Build.SourcesDirectory)/UKHOADDSMockService'
      xmlTransformationRules: ''
      jsonTargetFiles: '**/mock-configuration.json'

  - task: PowerShell@2
    displayName: Get a path for Service and Override Configuration
    inputs:
      targetType: 'inline'
      script: |
        # Find and print the path of the "service-configuration" folder

        Get-ChildItem -Path $(Build.SourcesDirectory) -Recurse -File

        Write-Host "======end of directory structure========"
        $folderPath = Get-ChildItem -Path $(Build.SourcesDirectory) -Recurse -Directory -Filter "service-configuration" | Select-Object -ExpandProperty FullName
        Write-Host "Service Configuration Path: $folderPath"
              
        # Print the pipeline variable "service-configuration"
        Write-Host "Pipeline Variable 'service-configuration': $env:ConfigurationPath"
              
        # Find and print the path of the "override-configuration" folder
        $folderPath = Get-ChildItem -Path $(Build.SourcesDirectory) -Recurse -Directory -Filter "override-configuration" | Select-Object -ExpandProperty FullName
        Write-Host "override-configuration Path: $folderPath"
              
        # Print the pipeline variable "override-configuration"
        Write-Host "Pipeline Variable 'service-configuration': $env:OverrideConfigurationPath"

  - task: PowerShell@2
    condition: always()
    inputs:
   
      targetType: 'inline'
      script: |
        $file = Get-ChildItem -Path "$(Build.SourcesDirectory)\UKHOADDSMockService" -Recurse -File -Filter "mock-configuration.json" | Select-Object -First 1
       
        if ($file) {
            # Read and print the content of the found file
            $content = Get-Content $file.FullName -Raw
            Write-Host "File Found: $($file.FullName)"
            Write-Host "Content: $content"
        } else {
            Write-Host "File 'mock-configuration.json' not found in $(Build.SourcesDirectory)"
        }

  - task: PowerShell@2
    inputs:
      targetType: 'inline'
      script: |
        $extractPath = "$(Build.SourcesDirectory)/UKHOADDSMockService"
              
        # Create the directory for extraction if it doesn't exist
              
        if (-Not (Test-Path -Path $extractPath)) {
              
            New-Item -ItemType Directory -Force -Path $extractPath
              
        }
              
        # List files in the extracted folder (optional, for debugging purposes)
              
        Write-Host "Listing files in extracted folder:"
              
        Get-ChildItem -Path $extractPath -Recurse | ForEach-Object { Write-Host $_.FullName }
              
        # Find the first executable file (.exe) in the extracted folder
              
        $exeFiles = Get-ChildItem -Path $extractPath -Recurse -Filter "*.exe"
              
        if ($exeFiles) {
              
            Write-Host "Found executable file: $($exeFiles[0].FullName)"
              
            # Execute the first found executable file in the background
              
            $exePath = $exeFiles[0].FullName
              
            Write-Host "Executing $exePath in the background"
              
            $process = Start-Process -FilePath $exePath -NoNewWindow -PassThru
              
            # Wait for the process to start (Modify this check as per your application's startup behavior)
              
            $timeout = 60  # Max wait time in seconds
              
            $elapsedTime = 0
              
            $isRunning = $false
              
            while ($elapsedTime -lt $timeout) {
              
                Start-Sleep -Seconds 5
              
                $elapsedTime += 5
              
                # Check if the process is running
              
                if (-Not $process.HasExited) {
              
                    $isRunning = $true
              
                    break
              
                }
              
            }   
              
            if ($isRunning) {
              
                Write-Host "Application started successfully!"
              
            } else {
              
                Write-Host "Error: Application failed to start within $timeout seconds."
              
                exit 1  # Fails the pipeline if the application doesn't start in time
              
            }
              
        } else {
              
            Write-Host "No executable files found in the ZIP artifact."
              
            exit 1  # Fails the pipeline if no executable is found
              
        }

  - task: PowerShell@2
    displayName: "Wait for Application to Start on https://localhost:5678"
    inputs:
      targetType: 'inline'
      script: |
        $port = 5678
        $url = "https://localhost:$port"
        $maxRetries = 5  # Wait for up to 60 seconds (5 retries * 5 seconds)
        $retryInterval = 5
        $attempt = 0
 
        Write-Host "Waiting for $url to be available..."
 
        while ($attempt -lt $maxRetries) {
            try {
                $response = Invoke-WebRequest -Uri $url -UseBasicParsing -TimeoutSec 3
                if ($response.StatusCode -eq 200) {
                    Write-Host "Application is running at $url!"
                    exit 0  # Exit successfully
                }
            } catch {
                Write-Host "$url is not responding, retrying in $retryInterval seconds..."
            }
 
            Start-Sleep -Seconds $retryInterval
            $attempt++
        }
 
        Write-Host "Error: Application did not start at $url within the timeout period."
        exit 1  # Fail pipeline if app is not running
        
  # - task: PowerShell@2
  #   displayName: Get a url for testing
  #   name: getUrl
  #   inputs:
  #     targetType: filePath
  #     filePath: '$(Build.SourcesDirectory)\src\MockSSSSS\Pipeline'

  - task: FileTransform@2
    displayName: "File Transform: functionaltests"
    inputs:
       folderPath: '$(Build.SourcesDirectory)/functionaltests/'
       xmlTransformationRules:
       jsonTargetFiles: '**/appsettings.json'

  - task: DotNetCoreCLI@2
    displayName: "Run Functional tests"
    inputs:
      command: "test"
      projects: |
          **/*FunctionalTest*.dll
          !**/*TestAdapter.dll
          !**/obj/**
      testRunTitle: "$(Environment)-AutomationTests"
      workingDirectory: '$(Build.SourcesDirectory)/functionaltests'
