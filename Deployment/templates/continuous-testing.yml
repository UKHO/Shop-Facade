parameters:
  - name: AzureSubscription
    type: string    

steps:
  - task: downloadbuildartifacts@0
    displayName: "download functional test artifact"
    inputs:
      buildtype: 'current'
      downloadtype: 'single'
      artifactname: 'functionaltests'
      downloadpath: '$(build.sourcesdirectory)'

  - task: DownloadBuildArtifacts@0
    displayName: "Download ADDSMock Artifact"
    inputs:
      buildType: 'current'
      downloadType: 'single'
      artifactName: 'UKHOADDSMockService'
      downloadPath: '$(Build.SourcesDirectory)'

  - task: PowerShell@2
    displayName: "Extract Artifact ZIP"
    inputs:
      targetType: "inline"
      script: |
        $artifactPath = "$(Build.SourcesDirectory)\UKHOADDSMockService"  # Path where artifact is downloaded
        $zipFile = Get-ChildItem -Path $artifactPath -Filter "*.zip" | Select-Object -First 1
        if ($zipFile) {
            Write-Host "Extracting: $($zipFile.FullName)"
            Expand-Archive -Path $zipFile.FullName -DestinationPath $artifactPath -Force
            Write-Host "Extraction completed!"
        } else {
            Write-Host "No ZIP file found in artifact!"
            exit 1
        }

  - task: UseDotNet@2
    displayName: 'Use .NET 8.0.x sdk'
    inputs:
      packageType: sdk
      version: 8.0.x

  - task: FileTransform@2
    displayName: "File Transform: Mock Service Settings"
    inputs:
      folderPath: '$(Build.SourcesDirectory)/UKHOADDSMockService'
      xmlTransformationRules: ''
      jsonTargetFiles: '**/mock-configuration.json'

  - task: PowerShell@2
    displayName: Get a path for Service and Override Configuration
    inputs:
      targetType: 'inline'
      script: |
        # Find and print the path of the "service-configuration" folder

        Get-ChildItem -Path $(Build.SourcesDirectory) -Recurse -File

        Write-Host "======end of directory structure========"
        $folderPath = Get-ChildItem -Path $(Build.SourcesDirectory) -Recurse -Directory -Filter "service-configuration" | Select-Object -ExpandProperty FullName
        Write-Host "Service Configuration Path: $folderPath"
              
        # Print the pipeline variable "service-configuration"
        Write-Host "Pipeline Variable 'service-configuration': $env:ConfigurationPath"
              
        # Find and print the path of the "override-configuration" folder
        $folderPath = Get-ChildItem -Path $(Build.SourcesDirectory) -Recurse -Directory -Filter "override-configuration" | Select-Object -ExpandProperty FullName
        Write-Host "override-configuration Path: $folderPath"
              
        # Print the pipeline variable "override-configuration"
        Write-Host "Pipeline Variable 'service-configuration': $env:OverrideConfigurationPath"

  - task: PowerShell@2
    condition: always()
    inputs:
   
      targetType: 'inline'
      script: |
        $file = Get-ChildItem -Path "$(Build.SourcesDirectory)\UKHOADDSMockService" -Recurse -File -Filter "mock-configuration.json" | Select-Object -First 1
       
        if ($file) {
            # Read and print the content of the found file
            $content = Get-Content $file.FullName -Raw
            Write-Host "File Found: $($file.FullName)"
            Write-Host "Content: $content"
        } else {
            Write-Host "File 'mock-configuration.json' not found in $(Build.SourcesDirectory)"
        }

  # - task: PowerShell@2
  #   displayName: Run the ADDSMock exe and health check for localhost
  #   inputs:
  #     targetType: 'inline'
  #     script: |
  #       $extractPath = "$(Build.SourcesDirectory)/UKHOADDSMockService"
       
  #       # Create the directory for extraction if it doesn't exist
      
  #       if (-Not (Test-Path -Path $extractPath)) {
      
  #           New-Item -ItemType Directory -Force -Path $extractPath
      
  #       }
       
  #       # List files in the extracted folder (optional, for debugging purposes)
      
  #       Write-Host "Listing files in extracted folder:"
      
  #       Get-ChildItem -Path $extractPath -Recurse | ForEach-Object { Write-Host $_.FullName }
       
  #       # Find the first executable file (.exe) in the extracted folder
      
  #       $exeFiles = Get-ChildItem -Path $extractPath -Recurse -Filter "*.exe"
       
  #       if ($exeFiles) {
      
  #           Write-Host "Found executable file: $($exeFiles[0].FullName)"
      
  #           # Execute the first found executable file in the background
      
  #           $exePath = $exeFiles[0].FullName
      
  #           Write-Host "Executing $exePath in the background"
 
  #           $process = Start-Process -FilePath $exePath -NoNewWindow -PassThru
       
  #           # Wait for 30 seconds before checking the health endpoint
      
  #           # Write-Host "Waiting for 30 seconds to allow the application to start..."
      
  #           # Start-Sleep -Seconds 30

  #           # Wait for 30 seconds while checking logs
  #           $elapsedTime = 0
  #           $timeout = 30

  #           while ($elapsedTime -lt $timeout) {
  #               Start-Sleep -Seconds 5
  #               $elapsedTime += 5

  #               # Fetch logs dynamically using Get-Process and checking output
  #               if (Get-Process | Where-Object { $_.Id -eq $process.Id }) {
  #                   Write-Host "`n[Application Logs] -----------------"
  #                   Get-Process | Where-Object { $_.Id -eq $process.Id } | ForEach-Object { Write-Host $_.MainWindowTitle }
  #               }
  #           }
       
  #           # Define the health check URL
      
  #           $url = "https://localhost:5678/demo/health"

  #           #Write-Host "check port"
  #           #netstat -ano | findstr :5678
  #           #Write-Host "check firewall"
  #           #Get-NetFirewallRule | Where-Object { $_.DisplayName -like "*5678*" }

  #           # Get the internal IP address of the machine
  #           #$internalIP = (Get-NetIPAddress -AddressFamily IPv4 | Where-Object {$_.InterfaceAlias -NotLike "Loopback*"}).IPAddress
  #           #Write-Host "Using Internal IP Address: $internalIP"


  #           # Check the health endpoint using curl
  #           #$url = "https://$internalIP:5678/demo/health"
       
  #           # Check the health endpoint using curl
      
  #           $curlResponse = curl.exe -k -s -o NUL -w "%{http_code}" $url

       
  #           if ($curlResponse -eq "200") {
      
  #               Write-Host " Application is running and responding at $url"
      
  #           } else {
      
  #               Write-Host " Warning: Application did not respond with 200 OK. Continuing pipeline..."
      
  #           }
       
  #       } else {
      
  #           Write-Host " No executable files found in the ZIP artifact."
      
  #       }


  - task: PowerShell@2
    displayName: "Set exePath pipeline variable"
    inputs:
      targetType: 'inline'
      script: |
        $exeFiles = Get-ChildItem -Path "$(Build.SourcesDirectory)/UKHOADDSMockService/" -Recurse -Filter "*.exe"
        Write-Host "exeFiles : $exeFiles"
        $exePath = "$(Build.SourcesDirectory)\\UKHOADDSMockService\\ADDSMock.exe"
        Write-Host "##vso[task.setvariable variable=ShopFacadeConfiguration.AddsMockExePath]$exePath"
        Write-Host "exePath is set to: $exePath"

  - task: FileTransform@2
    displayName: "File Transform: functionaltests"
    inputs:
       folderPath: '$(Build.SourcesDirectory)/functionaltests/'
       xmlTransformationRules:
       jsonTargetFiles: '**/appsettings.json'

  - task: PowerShell@2
    condition: always()
    inputs:
   
      targetType: 'inline'
      script: |
        $file = Get-ChildItem -Path "$(Build.SourcesDirectory)\functionaltests" -Recurse -File -Filter "appsettings.json" | Select-Object -First 1
       
        if ($file) {
            # Read and print the content of the found file
            $content = Get-Content $file.FullName -Raw
            Write-Host "File Found: $($file.FullName)"
            Write-Host "Content: $content"
        } else {
            Write-Host "File 'appsetting.json' not found in $(Build.SourcesDirectory)"
        }

  # - task: PowerShell@2
  #   displayName: ADDS Mock health check 2
  #   inputs:
  #     targetType: 'inline'
  #     script: |
  #       $timeout = 30   # Maximum wait time in seconds
      
  #       $elapsedTime = 0
      
  #       $healthUrl = "https://localhost:5678/demo/health"
       
  #       Write-Host "Checking if $healthUrl is available using curl..."
       
  #       while ($elapsedTime -lt $timeout) {
      
  #           $response = curl.exe -k -s -o NUL -w "%{http_code}" $healthUrl
      
  #           if ($response -eq "200") {
      
  #               Write-Host " Service is up and running!"
      
  #               break
      
  #           } else {
      
  #               Write-Host "Waiting for service to start... ($elapsedTime/$timeout seconds)"
      
  #           }
      
  #           Start-Sleep -Seconds 5
      
  #           $elapsedTime += 5
      
  #       }
       
  #       if ($elapsedTime -ge $timeout) {
      
  #           Write-Host "Warning: Service did not start within $timeout seconds."
      
  #       }

  - task: DotNetCoreCLI@2
    displayName: "Run Functional tests"
    inputs:
      command: "test"
      projects: |
          **/*FunctionalTest*.dll
          !**/*TestAdapter.dll
          !**/obj/**
      testRunTitle: "$(Environment)-AutomationTests"
      workingDirectory: '$(Build.SourcesDirectory)/functionaltests'
